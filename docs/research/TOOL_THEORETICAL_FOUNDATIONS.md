# MAIFS 각 Tool의 이론적 기반 및 전문화 전략

**작성일**: 2026-01-26
**목적**: 각 툴의 학문적 배경을 명확히 하고, 전문 분야에서 90%+ 성능 달성 전략 수립

---

## Executive Summary

### 현재 상태
- **Frequency Tool**: 자체 FFT 구현, 문헌 기반 (Wang et al., 2020)
- **Noise Tool**: SRM + PRNU (Lukas et al., 2006) + **MVSS-Net (ICCV 2021)**
- **Spatial Tool**: **TruFor** 또는 **OmniGuard (ViT)** 백엔드
- **EXIF Tool**: 메타데이터 분석 (자체 구현)

### 문제
각 툴이 **자신의 전문 영역에서도 50% 정답률** → 이론과 실제 구현 간 간극

### 목표
각 툴을 **전문 영역에서 90%+ 정답률**로 개선

---

## 1. Frequency Tool - FFT 기반 GAN 탐지

### 1.1 이론적 기반

#### 핵심 논문
1. **"CNN-generated images are surprisingly easy to spot... for now"**
   - Wang et al., CVPR 2020
   - GAN 생성 이미지의 주파수 도메인 특징적 패턴

2. **"Do GANs leave specific frequency signatures?"**
   - Dzanic et al., NeurIPS 2020
   - GAN별 고유 주파수 서명, 8x8/16x16 주기성

3. **"On the detection of synthetic images generated by diffusion models"**
   - Corvi et al., IEEE Access 2023
   - Diffusion 모델의 고주파 손실 특성

#### 과학적 원리

**GAN Artifacts의 물리적 원인:**
```
GAN Generator Architecture:
  Latent Vector → FC → Deconv Layers → Image

Transposed Convolution (stride=2):
  - Checkerboard artifacts at N/2, N/4 frequencies
  - FFT 스펙트럼에서 주기적 피크

Progressive Growing (ProGAN, StyleGAN):
  - 4x4 → 8x8 → 16x16 → ...
  - 각 단계별 주파수 아티팩트
```

**1/f^α Law (Power Spectrum):**
```
자연 이미지: α ≈ 2.0 (Pink noise, 1/f²)
  - 고주파로 갈수록 에너지 급격히 감소
  - 물리적 세계의 특성 반영

GAN 이미지: α ≈ 1.5-1.8
  - 고주파 복원 부족 (upsampling의 한계)
  - 부자연스러운 에너지 분포
```

### 1.2 현재 구현의 문제점

**구현된 특징:**
1. ✅ Grid Pattern (격자 패턴) - 기본적으로 작동
2. ✅ GAN Checkerboard - 새로 추가, BigGAN에서는 약함
3. ✅ Power Spectrum Slope - **double-log 버그 수정**
4. ⚠️ High-Frequency Abnormality - **자연 이미지에 과민 반응**

**문제:**
- HF Abnormality가 JPEG 압축 아티팩트를 AI 신호로 오인
- BigGAN은 이론과 달리 checkerboard가 약함
- **전문 영역**: StyleGAN, ProGAN, DCGAN 등 "고전 GAN"
- **약점 영역**: Diffusion models, BigGAN, JPEG 압축 이미지

### 1.3 전문화 전략

#### 전략 A: GAN-Type Specific Thresholds

**구현:**
```python
class FrequencyAnalysisTool:
    def _detect_gan_type(self, evidence):
        """GAN 유형 자동 감지"""

        checker = evidence["checkerboard_score"]
        grid = evidence["grid_score"]
        slope = evidence["slope_score"]

        # Classic GAN (ProGAN, StyleGAN v1)
        if checker > 0.6 and grid > 0.5:
            return "classic_gan", {
                "ai_threshold": 0.55,  # 낮은 threshold (쉬운 탐지)
                "confidence_boost": 0.2
            }

        # BigGAN (weak artifacts)
        elif slope > 0.8 and checker < 0.3:
            return "biggan", {
                "ai_threshold": 0.65,  # 높은 threshold (어려운 탐지)
                "confidence_penalty": 0.1
            }

        # Diffusion (no grid, low HF)
        elif grid < 0.2 and slope < 0.5:
            return "diffusion_suspected", {
                "verdict": Verdict.UNCERTAIN,  # 주파수만으로 불충분
                "explanation": "Diffusion 모델 의심. Noise/EXIF 분석 필요"
            }

        # Unknown
        else:
            return "unknown", {
                "ai_threshold": 0.70,  # 매우 보수적
                "confidence_penalty": 0.2
            }
```

#### 전략 B: JPEG-Aware Processing

**현재 문제**: JPEG 압축이 주파수 특성 왜곡

**개선:**
```python
def _jpeg_aware_analysis(self, image, evidence):
    """JPEG 압축 이미지 특화 분석"""

    is_jpeg = evidence["is_likely_jpeg"]

    if is_jpeg:
        # 1. DCT block 주파수 필터링
        # 8x8 블록 주파수는 제거 (JPEG 아티팩트)
        filtered_spectrum = self._filter_dct_frequencies(spectrum)

        # 2. HF Abnormality 가중치 감소
        hf_score = evidence["hf_abnormality"] * 0.3  # 70% 감소

        # 3. Slope 보정
        # JPEG은 고주파 손실 → slope 낮아짐
        slope_threshold_adjusted = 1.0  # 1.2에서 하향

        # 4. Conservative threshold
        ai_threshold = 0.70  # PNG: 0.60
        auth_threshold = 0.30  # PNG: 0.35

        return {
            "jpeg_adjusted": True,
            "ai_threshold": ai_threshold,
            "hf_weight": 0.05,  # 기본 0.05에서 유지 (이미 낮음)
            "slope_threshold": slope_threshold_adjusted
        }
```

#### 전략 C: Confidence Gating

**원칙**: "확실하지 않으면 UNCERTAIN"

```python
def _confidence_gating(self, score, evidence):
    """신뢰도 기반 판정 필터링"""

    # 1. Feature Agreement Check
    features = [
        evidence["grid_score"],
        evidence["checkerboard_score"],
        evidence["slope_score"]
    ]
    feature_std = np.std(features)

    if feature_std > 0.4:  # 특징 간 큰 차이
        return Verdict.UNCERTAIN, 0.5, "특징 간 불일치"

    # 2. JPEG Penalty
    if evidence["is_likely_jpeg"]:
        if score < 0.70:  # JPEG는 더 높은 기준
            return Verdict.UNCERTAIN, 0.5, "JPEG 압축으로 신뢰도 낮음"

    # 3. Weak Evidence
    all_features_low = all(f < 0.4 for f in features)
    if all_features_low and score < 0.65:
        return Verdict.UNCERTAIN, 0.5, "모든 특징 약함"

    # 4. Threshold 근처
    if 0.45 < score < 0.55:
        return Verdict.UNCERTAIN, 0.5, "임계값 근처 (회색지대)"

    # 통과 → 기존 로직
    return None
```

### 1.4 목표 성능

**전문 영역 (Classic GAN - StyleGAN, ProGAN, DCGAN):**
- PNG 이미지
- 격자/체커보드 패턴 명확
- **목표**: Precision 95%+, Recall 90%+

**보조 영역 (BigGAN):**
- Slope 특징 의존
- **목표**: Precision 80%+, Recall 60%+

**UNCERTAIN 처리 (Diffusion, 고압축 JPEG):**
- 주파수만으로 판정 불가
- **목표**: UNCERTAIN 40%+, Wrong < 10%

---

## 2. Noise Tool - SRM + PRNU + MVSS-Net

### 2.1 이론적 기반

#### 핵심 논문

**PRNU (Photo Response Non-Uniformity):**
1. **"Digital camera identification from sensor pattern noise"**
   - Lukas et al., IEEE TIFS 2006
   - 카메라 센서의 물리적 "지문"

2. **"Noiseprint: a CNN-based camera model fingerprint"**
   - Cozzolino et al., IEEE TIFS 2019
   - 딥러닝 기반 노이즈 패턴 추출

**MVSS-Net (Image Manipulation Detection):**
3. **"Image Manipulation Detection by Multi-View Multi-Scale Supervision"**
   - Dong et al., ICCV 2021
   - Multi-view, multi-scale supervision으로 조작 영역 탐지

4. **MVSS-Net++**
   - Dong et al., IEEE T-PAMI 2022
   - 개선된 버전, Real-world forgery localization

#### 과학적 원리

**PRNU의 물리적 근거:**
```
카메라 센서 제조 과정:
  실리콘 웨이퍼 → 포토다이오드 어레이

각 픽셀의 감광 민감도 차이:
  I(x,y) = I₀(x,y) × [1 + K(x,y)] + Θ(x,y)

  K(x,y): PRNU 패턴 (카메라마다 고유)
  → 제조 과정의 불완전성
  → 소프트웨어로 위조 불가능
```

**AI 생성 이미지의 특징:**
- GAN/Diffusion은 PRNU를 "학습"하지 않음
- 훈련 데이터의 PRNU는 모두 다름 → 학습 불가
- **결과**: PRNU 패턴 없음 또는 무작위

**MVSS-Net의 원리:**
```
Multi-View:
  - RGB input
  - SRM filters (30개 noise filters)
  - Edge information

Multi-Scale:
  - Feature Pyramid Network
  - 다양한 해상도에서 조작 탐지

Supervision:
  - Pixel-level mask prediction
  - Edge supervision
  - Binary classification
```

### 2.2 현재 구현의 문제점

**두 가지 백엔드:**
1. **PRNU Mode** (기본):
   - SRM 필터 + PRNU 추출
   - 블록별 노이즈 일관성 분석
   - **문제**: JPEG 압축에 매우 취약

2. **MVSS Mode** (선택):
   - 딥러닝 기반 조작 탐지
   - CASIA2 데이터셋 학습
   - **문제**: AI 생성 이미지에 특화되지 않음 (조작 탐지 모델)

**성능 문제:**
- MVSS threshold=0.84는 너무 높음 (과신)
- UNCERTAIN을 3%만 사용 → aggressive
- **전문 영역**: 조작된 이미지 (splicing, copy-move)
- **약점 영역**: AI 생성 이미지 (특히 BigGAN 고품질)

### 2.3 전문화 전략

#### 전략 A: Dual-Purpose Optimization

**인식의 전환:**
- Noise Tool ≠ AI 생성 탐지 도구
- Noise Tool = **조작 탐지** + **카메라 인증** 도구

**전문 영역 재정의:**
```python
class NoiseAnalysisTool:
    def analyze(self, image):
        """목적 기반 분석"""

        # 1. MVSS로 조작 탐지 (전문 영역)
        if self.backend == "mvss":
            manipulation_result = self._detect_manipulation_mvss(image)

            if manipulation_result["mvss_score"] > 0.70:
                # 확실한 조작
                return ToolResult(
                    verdict=Verdict.MANIPULATED,
                    confidence=0.9,
                    explanation="MVSS-Net이 조작 영역 탐지"
                )

        # 2. PRNU로 카메라 인증 (보조 영역)
        prnu_result = self._analyze_prnu(image)

        if prnu_result["prnu_consistency"] > 0.80:
            # 확실한 카메라 촬영
            return ToolResult(
                verdict=Verdict.AUTHENTIC,
                confidence=0.95,
                explanation="강한 PRNU 패턴, 카메라 촬영 확실"
            )

        # 3. AI 생성 추론 (간접적)
        if prnu_result["prnu_consistency"] < 0.20:
            # PRNU 없음 → AI 생성 가능성
            return ToolResult(
                verdict=Verdict.AI_GENERATED,
                confidence=0.6,  # 낮은 확신 (간접 증거)
                explanation="PRNU 패턴 부재, AI 생성 가능성"
            )

        # 4. 불확실
        return ToolResult(
            verdict=Verdict.UNCERTAIN,
            confidence=0.5,
            explanation="중간 PRNU, 명확한 판정 불가"
        )
```

#### 전략 B: Conservative MVSS Thresholding

**현재 문제**: threshold=0.84는 조작된 이미지만 탐지

**개선:**
```python
# Before (Aggressive)
mvss_threshold = 0.84
mvss_auth_threshold = 0.84
uncertain_margin = 0.0

# After (Conservative)
mvss_threshold = 0.65        # 조작 확실
mvss_auth_threshold = 0.40   # 자연 확실
uncertain_margin = 0.25      # 0.40-0.65 불확실

# 판정 로직
if mvss_score >= 0.65:
    verdict = MANIPULATED
    confidence = min(mvss_score, 0.95)
elif mvss_score <= 0.40:
    verdict = AUTHENTIC
    confidence = 1.0 - mvss_score
else:
    verdict = UNCERTAIN  # 40-65% 구간
    confidence = 0.5
```

#### 전략 C: JPEG-Aware PRNU

**현재 문제**: JPEG 압축이 PRNU 손상

**개선:**
```python
def _jpeg_tolerant_prnu(self, image, evidence):
    """JPEG에 강건한 PRNU 분석"""

    # 1. JPEG 품질 추정
    jpeg_quality = self._estimate_jpeg_quality(image)

    # 2. Quality 기반 threshold 조정
    if jpeg_quality < 75:  # 고압축
        prnu_threshold_authentic = 0.50  # 기본 0.80에서 하향
        confidence_penalty = 0.3
    elif jpeg_quality < 90:  # 중압축
        prnu_threshold_authentic = 0.65
        confidence_penalty = 0.15
    else:  # 저압축/무압축
        prnu_threshold_authentic = 0.80
        confidence_penalty = 0.0

    # 3. PRNU 일관성 측정
    prnu_consistency = evidence["prnu_corr_mean"]

    # 4. Adjusted 판정
    if prnu_consistency > prnu_threshold_authentic:
        confidence = min(0.95, prnu_consistency - confidence_penalty)
        return Verdict.AUTHENTIC, confidence
    elif prnu_consistency < 0.30:
        return Verdict.AI_GENERATED, 0.7
    else:
        return Verdict.UNCERTAIN, 0.5
```

### 2.4 목표 성능

**전문 영역 (Image Manipulation - splicing, copy-move):**
- MVSS-Net 활용
- **목표**: Precision 90%+, Recall 85%+

**보조 영역 (Camera Authentication):**
- PRNU 강한 이미지 (RAW, 저압축 JPEG)
- **목표**: Precision 95%+, Recall 70%+

**약점 영역 (AI Generation Detection):**
- 간접 추론만 가능 (PRNU 부재)
- **목표**: UNCERTAIN 50%+, Wrong < 15%

---

## 3. Spatial Tool - TruFor / OmniGuard

### 3.1 이론적 기반

#### TruFor (CVPR 2023)
- RGB + Noiseprint++ 기반 멀티모달 포렌식
- Transformer 융합으로 localization map + detection score 출력
- Pixel-level localization

#### OmniGuard
- Hybrid Manipulation Localization via Augmented Versatile Deep Image Watermarking
- Window Attention ViT + FPN 기반
- 조작 영역 탐지 특화

### 3.2 전문 영역
- **조작 영역 명확한 이미지**
- Inpainting, splicing, copy-move
- 경계선 불일치

### 3.3 전문화 전략

**Conservative Localization:**
```python
def _confidence_based_verdict(self, manipulation_ratio, max_score):
    """조작 비율 + 최대 점수 기반 판정"""

    # 명확한 조작 (높은 비율, 높은 확신)
    if manipulation_ratio > 0.20 and max_score > 0.75:
        return Verdict.MANIPULATED, 0.9

    # 미세 조작 (낮은 비율, 높은 확신)
    elif manipulation_ratio > 0.05 and max_score > 0.85:
        return Verdict.MANIPULATED, 0.8

    # 조작 없음 (낮은 비율, 낮은 확신)
    elif manipulation_ratio < 0.02 and max_score < 0.40:
        return Verdict.AUTHENTIC, 0.8

    # 불확실
    else:
        return Verdict.UNCERTAIN, 0.5
```

---

## 4. 통합 전략: Specialization Matrix

### 4.1 각 툴의 전문 영역 매트릭스

| Tool | 최고 전문 영역 | 목표 성능 | 보조 영역 | 목표 성능 | UNCERTAIN 처리 |
|------|---------------|----------|----------|----------|---------------|
| **Frequency** | Classic GAN (StyleGAN, ProGAN, DCGAN) PNG | P:95%, R:90% | BigGAN | P:80%, R:60% | Diffusion, JPEG 고압축 → 40%+ |
| **Noise** | Image Manipulation (splicing, copy-move) | P:90%, R:85% | Camera Auth (PRNU) | P:95%, R:70% | AI Generation → 50%+ |
| **Spatial** | Manipulation Localization | P:95%, R:90% | Boundary Detection | P:85%, R:75% | Full AI-gen → 60%+ |
| **EXIF** | Metadata Anomaly | P:98%, R:95% | Software Tag | P:95%, R:90% | Normal EXIF → 30%+ |

### 4.2 Image Type Routing

**이미지 특성 자동 감지 → 전문 툴 가중치 조정:**

```python
def route_to_specialist(image, metadata):
    """이미지 타입별 전문 툴 선택"""

    weights = {
        "frequency": 1.0,
        "noise": 1.0,
        "spatial": 1.0,
        "exif": 1.0
    }

    # PNG + 고해상도 → Frequency/Noise 강화
    if metadata["format"] == "PNG" and metadata["resolution"] > 1024:
        weights["frequency"] *= 2.0
        weights["noise"] *= 1.5

    # JPEG + EXIF 풍부 → EXIF/Spatial 강화
    elif metadata["format"] == "JPEG" and metadata["has_rich_exif"]:
        weights["exif"] *= 2.5
        weights["spatial"] *= 1.5
        weights["frequency"] *= 0.6  # 약화
        weights["noise"] *= 0.7

    # 조작 의심 (경계선 명확) → Spatial 강화
    if metadata["has_sharp_boundaries"]:
        weights["spatial"] *= 2.0

    return weights
```

### 4.3 Consensus Strategy

**High-Confidence Voting:**

```python
def specialized_consensus(tool_results, weights):
    """전문성 기반 합의"""

    # 1. High Confidence만 투표
    high_conf = [
        (r, w) for r, w in zip(tool_results, weights.values())
        if r.confidence >= 0.80 and r.verdict != Verdict.UNCERTAIN
    ]

    if not high_conf:
        return Verdict.UNCERTAIN, 0.5, "모든 도구 낮은 확신"

    # 2. Weighted Voting
    ai_weight = sum(
        r.confidence * w for r, w in high_conf
        if r.verdict == Verdict.AI_GENERATED
    )
    auth_weight = sum(
        r.confidence * w for r, w in high_conf
        if r.verdict == Verdict.AUTHENTIC
    )

    # 3. 전문 툴의 의견 우선
    # (가중치 2.0 이상 = 전문 영역)
    specialist_votes = [r for r, w in high_conf if w >= 2.0]

    if len(specialist_votes) == 1:
        # 단일 전문가 의견 존재 → 우선 채택
        return specialist_votes[0].verdict, specialist_votes[0].confidence * 1.1

    # 4. 일반 투표
    if ai_weight > auth_weight * 1.3:
        return Verdict.AI_GENERATED, ai_weight / (ai_weight + auth_weight)
    elif auth_weight > ai_weight * 1.3:
        return Verdict.AUTHENTIC, auth_weight / (ai_weight + auth_weight)
    else:
        return Verdict.UNCERTAIN, 0.5, "도구 간 의견 불일치"
```

---

## 5. 실행 계획

### Phase 1: Conservative Thresholding (즉시)

**Frequency Tool:**
```json
{
  "ai_threshold": 0.60,
  "auth_threshold": 0.35,
  "uncertain_margin": 0.25,
  "min_confidence": 0.70
}
```

**Noise Tool:**
```json
{
  "mvss_threshold": 0.65,
  "mvss_auth_threshold": 0.40,
  "uncertain_margin": 0.25,
  "prnu_authentic_threshold": 0.65,  # JPEG 고려
  "min_confidence": 0.75
}
```

**예상 효과:**
- Wrong: 40% → 15%
- Uncertain: 10% → 30%
- Correct: 50% → 55%

### Phase 2: Confidence Gating (1주)

**구현:**
- `_confidence_gating()` 추가
- Feature agreement check
- JPEG penalty
- Weak evidence filtering

### Phase 3: Domain-Specific Optimization (2주)

**구현:**
- GAN-type detection
- JPEG-aware processing
- Image type routing

**검증:**
- StyleGAN/ProGAN 데이터셋 확보
- CASIA2 조작 데이터셋 테스트
- 각 전문 영역별 성능 측정

### Phase 4: Specialized Consensus (2주)

**구현:**
- Routing system
- Weighted voting
- Specialist priority

---

## 6. 성공 지표

### 개별 툴 (전문 영역)

**Frequency on Classic GAN (PNG):**
- Precision: 95%+
- Recall: 90%+
- Wrong: < 5%

**Noise on Manipulation:**
- Precision: 90%+
- Recall: 85%+
- Wrong: < 10%

### 시스템 전체

**High Confidence Consensus:**
- Precision: 95%+
- Coverage: 70%+ (UNCERTAIN 30%)

**Both Tools Wrong:**
- < 5% (현재 18%)

---

## 7. 결론

### 핵심 인사이트

1. **각 툴은 이미 강력한 이론적 기반을 가짐**
   - Frequency: Wang et al. (CVPR 2020)
   - Noise: Lukas et al. (TIFS 2006) + MVSS-Net (ICCV 2021)
   - 문제는 구현과 threshold 설정

2. **Generalist → Specialist 전환 필수**
   - 모든 이미지를 판정하려 하지 말 것
   - 전문 영역에서만 확실하게 판정
   - 나머지는 UNCERTAIN → 다른 툴에 위임

3. **JPEG는 모든 툴의 천적**
   - Frequency: 고주파 손실, 8x8 블록 아티팩트
   - Noise: PRNU 약화
   - 해결: JPEG-aware processing

4. **Noise Tool의 목적 재정의**
   - AI 생성 탐지 도구 (X)
   - 조작 탐지 + 카메라 인증 도구 (O)
   - AI 생성은 간접 추론만 가능

### 즉시 실행

**오늘:**
1. ✅ Conservative threshold 적용
2. ✅ Confidence gating 구현

**이번 주:**
3. JPEG-aware processing
4. GAN-type detection

**2주 내:**
5. Specialized consensus
6. 전문 영역별 성능 검증

---

**Report ID**: TOOL-THEORY-20260126
**Next Action**: Conservative thresholding 적용 및 테스트

---

## 툴 전문화 전략 요약

### 현재 상호보완성 분석 (측정 기준: Frequency + Noise 기반)

| 케이스 | 비율 | 의미 |
|--------|------|------|
| Both Correct | 22% | 두 툴 합의, 신뢰도 높음 |
| Freq Only Correct | 22% | Frequency 전문 영역 |
| Noise Only Correct | 23% | Noise 전문 영역 |
| Both Wrong | 18% | 시스템 취약점 |
| **Complementary Benefit** | **45%** | 멀티에이전트 구조의 가치 |

**핵심 원칙**: Generalist → Specialist 전환. 확실한 영역만 판정하고 불확실하면 `UNCERTAIN`으로 위임.

### 전략별 기대 효과

| 전략 | 설명 | 기대 효과 |
|------|------|-----------|
| **Conservative Thresholding** | 임계값 높여 확실할 때만 판정 | Wrong 41% → 15% |
| **UNCERTAIN 적극 활용** | 불확실하면 다른 툴에 위임 | Uncertain 12% → 25-30% |
| **Domain Router** | PNG→Frequency/Noise 강화, JPEG→EXIF/Spatial 강화 | Union Coverage 67% → 80%+ |
| **Two-Stage Filtering** | 1차 도구 필터링 → 2차 LLM 판단 | High Confidence Precision 90%+ |
